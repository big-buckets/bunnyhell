<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Bunny Hell</title>
    <script src="https://cdn.jsdelivr.net/npm/phaser@3.55.2/dist/phaser.js"></script>
    <style>
        body { margin: 0; }
        canvas { display: block; }
    </style>
</head>
<body>
    <script>
        const config = {
            type: Phaser.AUTO,
            width: 2000,
            height: 600,
            physics: {
                default: 'arcade',
                arcade: {
                    gravity: { y: 500 },
                    debug: false
                }
            },
            scene: {
                preload: preload,
                create: create,
                update: update
            }
        };

        const game = new Phaser.Game(config);

        let player;
        let bullets;
        let enemies;
        let portals;
        let level = 1;
        let enemyCount = 0;
        let keyA;
        let keyD;
        let keyW;
        let sceneRef;
        let timer;
        let timerText;
        let timeElapsed = 0;
        let gameOverText;

        function preload() {
            this.load.image('background', 'assets/background.jpg'); // Load the background image
            this.load.image('player', 'assets/player.png');
            this.load.image('bullet', 'assets/bullet.png');
            this.load.image('enemy', 'assets/enemy.png');
            this.load.image('portal', 'assets/portal.png');
        }

        function create() {
            sceneRef = this;
            this.add.image(400, 300, 'background').setScrollFactor(0); // Add the background image

            keyA = this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.A);
            keyD = this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.D);
            keyW = this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.W);

            player = this.physics.add.sprite(100, 450, 'player');
            player.setCollideWorldBounds(true);

            bullets = this.physics.add.group({
                allowGravity: false,
                collideWorldBounds: false
            });

            enemies = this.physics.add.group();
            spawnEnemies.call(this);

            portals = this.physics.add.group({
                allowGravity: false,
                collideWorldBounds: true
            });
            spawnPortal.call(this);

            this.physics.add.collider(player, enemies, playerHitEnemy);
            this.physics.add.collider(bullets, enemies, bulletHitEnemy);
            this.physics.add.collider(player, portals, nextLevel, null, this);

            this.input.keyboard.on('keydown-Z', shootBullet, this);

            timerText = this.add.text(680, 20, 'Time: 0s', { fontSize: '20px', fill: '#fff' });
            timer = this.time.addEvent({ delay: 1000, callback: updateTimer, callbackScope: this, loop: true });

            gameOverText = this.add.text(400, 300, 'Game Over', { fontSize: '48px', fill: '#ff0000', align: 'center' });
            gameOverText.setOrigin(0.5);
            gameOverText.setVisible(false);
        }

        function update() {
            if (keyA.isDown || keyD.isDown) {
                if (keyA.isDown) {
                    player.setVelocityX(-260);
                } else if (keyD.isDown) {
                    player.setVelocityX(260);
                }
            } else {
                player.setVelocityX(0);
            }

            // Check if the player is touching the ground and the 'W' key is pressed
            if (keyW.isDown) {
                player.setY(player.y - 20); // Increment the y-axis position by 20
            }

            // Check for bullets out of screen and destroy them
            bullets.children.each(function(bullet) {
                if (bullet.y < 0 || bullet.y > game.config.height) {
                    bullet.destroy();
                }
            });
        }

        function shootBullet() {
            const bullet = bullets.create(player.x, player.y, 'bullet');
            bullet.setVelocityX(400);
        }

        function spawnEnemies() {
            const numEnemies = Phaser.Math.Between(1, 2) * level; // Random number of enemies based on the level
            for (let i = 0; i < numEnemies; i++) {
                const enemy = enemies.create(Phaser.Math.Between(50, 750), Phaser.Math.Between(50, 300), 'enemy');
                enemy.setCollideWorldBounds(true);
                enemy.setBounce(1);
                enemy.setVelocityX(Phaser.Math.Between(-100, 100));
                enemy.setVelocityY(Phaser.Math.Between(-100, 100));
                enemy.setCircle(20);
                enemyCount++;
            }
        }

        function spawnPortal() {
            const portal = portals.create(Phaser.Math.Between(50, 750), Phaser.Math.Between(50, 550), 'portal'); // Randomize portal position
            portal.setCollideWorldBounds(true);
        }

        function playerHitEnemy(player, enemy) {
            gameOverText.setVisible(true);
            sceneRef.time.delayedCall(1000, restartGame, [], sceneRef); // Restart the game after 1 second
            timeElapsed = 0; // Reset the time elapsed when player dies
        }

        function bulletHitEnemy(bullet, enemy) {
            bullet.destroy();
            enemy.destroy();
            enemyCount--;
        }

        function nextLevel() {
            level++;
            enemyCount = 0;
            enemies.clear(true, true);
            bullets.clear(true, true);
            portals.clear(true, true);
            spawnEnemies.call(this);
            spawnPortal.call(this);
            timeElapsed = 0; // Reset the time elapsed when player reaches the next level
        }

        function updateTimer() {
            timeElapsed++;
            timerText.setText('Time: ' + timeElapsed + 's');
        }

        function restartGame() {
            gameOverText.setVisible(false);
            sceneRef.scene.restart();
        }
    </script>
</body>
</html>
